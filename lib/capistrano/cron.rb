# frozen_string_literal: true

require "capistrano/plugin"

module Capistrano
  class Cron < Capistrano::Plugin
    def set_defaults
      set_if_empty :cron_roles, %w[db]
      set_if_empty :cron_identifier, -> { "#{fetch(:application)}_#{fetch(:stage)}" }
      set_if_empty :cron_environment, -> { fetch(:stage) }
      set_if_empty :cron_schedule_path, "config/schedule.rb"
    end

    def define_tasks
      eval_rakefile File.expand_path("../tasks/cron.rake", __FILE__)
    end

    def register_hooks
      after "deploy:updated", "cron:update"
      after "deploy:reverted", "cron:update"
    end

    def update_crontab
      install_crontab(schedule_cron)
    end

    def clear_crontab
      install_crontab("")
    end

    def identifier
      fetch(:cron_identifier)
    end

    private

    def current_crontab
      @current_crontab ||= begin
        contents = backend.capture(:crontab, "-l")

        # Strip n lines from the top of the file as specified by the :cut option.
        # Use split with a -1 limit option to ensure the join is able to rebuild
        # the file with all of the original seperators in-tact.
        stripped_contents = contents.split($/, -1).join($/)

        # Some cron implementations require all non-comment lines to be newline-
        # terminated. (issue #95) Strip all newlines and replace with the default
        # platform record seperator ($/)
        stripped_contents.gsub(/\s+$/, $/)
      end
    end

    def install_crontab(content)
      file = release_path.join("tmp", "#{identifier}.cron")
      backend.upload! StringIO.new(updated_crontab(content)), file
      backend.execute :cat, file, "| crontab -"
    end

    def schedule_cron
      @schedule_cron ||= [comment_open, job_list.generate_cron_output.strip, comment_close].compact.join("\n") + "\n"
    end

    def job_list
      @job_list ||= JobList.new(
        file: fetch(:cron_schedule_path),
        identifier: identifier,
        roles: fetch(:cron_roles),
        path: current_path,
        environment: fetch(:cron_environment),
        bundle_command: expanded_bundle_command
      )
    end

    def expanded_bundle_command
      backend.capture(:echo, SSHKit.config.command_map[:bundle]).strip
    end

    def updated_crontab(cron)
      # Check for unopened or unclosed identifier blocks
      if current_crontab =~ Regexp.new("^#{comment_open}\s*$") && (current_crontab =~ Regexp.new("^#{comment_close}\s*$")).nil?
        fail "Unclosed indentifier; Your crontab file contains '#{comment_open}', but no '#{comment_close}'"
      elsif (current_crontab =~ Regexp.new("^#{comment_open}\s*$")).nil? && current_crontab =~ Regexp.new("^#{comment_close}\s*$")
        fail "Unopened indentifier; Your crontab file contains '#{comment_close}', but no '#{comment_open}'"
      end

      # If an existing identifier block is found, replace it with the new cron entries
      if current_crontab =~ Regexp.new("^#{comment_open}\s*$") && current_crontab =~ Regexp.new("^#{comment_close}\s*$")
        # If the existing crontab file contains backslashes they get lost going through gsub.
        # .gsub('\\', '\\\\\\') preserves them. Go figure.
        current_crontab.gsub(Regexp.new("^#{comment_open}\s*$.+^#{comment_close}\s*$", Regexp::MULTILINE), cron.chomp.gsub("\\", "\\\\\\"))
      else # Otherwise, append the new cron entries after any existing ones
        [current_crontab, cron].join("\n\n")
      end.gsub(/\n{3,}/, "\n\n") # More than two newlines becomes just two.
    end

    def comment_open
      "# >>> #{identifier} jobs generated by capistrano-cron"
    end

    def comment_close
      "# <<< #{identifier} jobs"
    end
  end
end

require_relative "cron/numeric_ext"
require_relative "cron/job_list"
